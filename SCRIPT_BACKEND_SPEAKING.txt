
═══════════════════════════════════════════════════════════════════════════════
PEMBUKAAN
═══════════════════════════════════════════════════════════════════════════════

"Assalamu'alaikum semua. Saya kali ini mau menjelaskan bagian backend dari 
aplikasi typing game yang saya bikin.

Jadi, backend itu adalah otak dari aplikasinya. Frontend yang kalian lihat, 
itu hanya display. Tapi semua perhitungan, logic, dan cara kerjanya, itu semua 
ada di backend. Kalo frontend adalah tokonya, backend adalah gudangnya.

Saya pakai satu class besar yang namanya TypingGameBackend. Semua method dan 
attribute ada di sini.

═══════════════════════════════════════════════════════════════════════════════
DATA & SETUP
═══════════════════════════════════════════════════════════════════════════════

Ada PARAGRAPHS. Ini adalah kumpulan 5 paragraf panjang yang semuanya 
bahasa Indonesia. Mulai dari pemanasan global, batik, kopi, literasi digital, 
sampai revolusi industri. Paragraf-paragraf ini akan dipakai sebagai teks 
untuk mode tes kecepatan.

Terus ada yang namanya DRILL_PATTERNS. Ini adalah pola latihan untuk 
melatih ketikan. Misalnya, 'aaa ' (a diulang 3 kali terus spasi). Ini berguna 
untuk melatih jari agar cepat dan akurat. Soalnya, kalau kita latihan dengan 
teks random, jari kita gak fokus. Dengan pola ini, jari bisa fokus di satu 
lokasi.

Ada 3 tipe pola:
- HOME_ROW: a s d f j k l ; (baris tengah keyboard)
- TOP_ROW: q w e r t y u i o p (baris atas)
- BOTTOM_ROW: z x c v b n m , . / (baris bawah)

Jadi, kalau user memilih 'Latihan Baris Tengah', backend akan generate teks 
dari HOME_ROW patterns aja. Praktis, kan?

Terus ada ALL_WORDS. Ini adalah semua kata dari semua paragraphs yang sudah 
digabung menjadi satu array. Soalnya nanti kalau tes kecepatan, kita perlu 
random pilih kata dari sini.


═══════════════════════════════════════════════════════════════════════════════
METHOD 1: SET_MODE
═══════════════════════════════════════════════════════════════════════════════

"Sekarang kita ke method pertama: set_mode.

Fungsinya sederhana. Ini adalah method untuk 'mengatur mode permainan'. 
Kalau user klik 'Tes Kecepatan', backend akan panggil set_mode dengan 
mode='time' dan value=60 (artinya 60 detik).

Atau kalau user pilih 'Latihan Baris Tengah', maka set_mode akan dipanggil 
dengan mode='home_row_drill' dan value=50 (50 pola).

Di dalam method ini, kita set max_time dan word_count berdasarkan apa mode-nya. 
Kalau mode time, word_count kita set 0 karena tidak dipakai. Sebaliknya, 
kalau mode drill, max_time kita set 0 karena tidak dipakai.

Setelah itu, method akan panggil reset_game() untuk reset semua state 
agar siap permainan baru."

═══════════════════════════════════════════════════════════════════════════════
METHOD 2: RESET_GAME
═══════════════════════════════════════════════════════════════════════════════

"Method reset_game adalah reset total. Semua state dikembalikan ke kondisi awal.

char_index diset 0. Artinya kita mulai dari karakter pertama lagi.
mistakes diset 0. Kesalahan lama dihapus.
start_time diset 0. Belum ada waktu mulai.
timer_running diset False. Timer belum jalan.
game_over_flag diset False. Game belum selesai.

Terus time_left diset sesuai mode. Kalau time mode, time_left diset 60. 
Kalau drill mode, time_left diset 0 (karena belum mulai, jadi elapsed time = 0).

Setelah semua ini, method panggil load_paragraph(). Ini method lain yang 
akan generate teks baru sesuai mode yang dipilih.

Jadi reset_game ini seperti 'reset otak'. Semua ingatan lama dihapus, siap 
untuk game baru."

═══════════════════════════════════════════════════════════════════════════════
METHOD 3: GENERATE_DRILL_TEXT & LOAD_PARAGRAPH
═══════════════════════════════════════════════════════════════════════════════

"Sekarang generate_drill_text dan load_paragraph.

generate_drill_text adalah helper method untuk membuat teks latihan dari 
pola-pola yang diberikan. Misalnya, kalau kita pass HOME_ROW_PATTERNS, 
method ini akan random ambil dari pola-pola itu sebanyak word_count * 3 kali, 
terus gabung menjadi satu string panjang.

Jadi kalau word_count = 50, dan setiap pola itu 4 karakter (char + 3 spasi), 
maka hasilnya kira-kira 200 karakter.

load_paragraph adalah yang menentukan teks apa yang harus diketik sesuai mode.

Kalau mode time:
  - Ambil 300 kata random dari ALL_WORDS, gabung dengan spasi
  - Hasilnya teks panjang bertipe 'pemanasan global dikenal batik...'

Kalau mode drill:
  - Panggil generate_drill_text dengan DRILL_PATTERNS (semua huruf)
  - Hasilnya 'aaa  sss  ddd  fff  jjj  kkk...'

Kalau mode home_row_drill:
  - Panggil generate_drill_text dengan HOME_ROW_PATTERNS
  - Hasilnya 'aaa  sss  ddd  fff  jjj  kkk  lll  ;;;  aaa...'
  - Hanya huruf tengah aja

Sama dengan top_row_drill dan bottom_row_drill.

Teks yang dihasilkan disimpan di current_text. Ini adalah teks yang akan 
ditampilkan di UI dan yang akan user ketik."

═══════════════════════════════════════════════════════════════════════════════
METHOD 4: PROCESS_KEY [YANG PALING PENTING!]
═══════════════════════════════════════════════════════════════════════════════

"Sekarang method yang paling penting: process_key.

Setiap kali user menekan tombol keyboard, method ini dipanggil. Frontend akan 
kirim dua informasi: char (karakter yang diketik) dan keysym (nama tombol).

Contoh: User tekan tombol 'a'. Maka char='a', keysym='a'.
Atau user tekan Shift+A. Maka char='A', keysym='a'.

Method ini punya beberapa checkpoint:

CHECKPOINT 1: Apakah game sudah selesai?
Kalau game_over_flag = True, berarti permainan sudah selesai. 
Jika user tekan tombol apapun kecuali Return, kita abaikan.

CHECKPOINT 2: Apakah tombol adalah modifier?
Caps Lock, Shift, Control, Alt... ini adalah tombol yang tidak menghasilkan 
karakter. Kalau user tekan, kita abaikan.

CHECKPOINT 3: Apakah Backspace?
Kalau user tekan Backspace, kita mundur satu karakter. char_index dikurangi 1.
Frontend akan diberitahu untuk hapus tag warna dari karakter tersebut.

CHECKPOINT 4: Apakah karakter normal (printable)?
Nah, ini adalah yang utama. Kalau char panjangnya 1 dan ASCII value-nya >= 32 
(artinya karakter printable, bukan kontrol), maka kita proses.

Pertama, cek apakah timer sudah jalan. Kalau belum, mulai timer sekarang 
dengan set start_time = time.time().

Terus, ambil karakter yang seharusnya diketik dari current_text[char_index].
Bandingkan dengan char yang user ketik. Apakah match?

Kalau match, is_correct = True. Kalau tidak, is_correct = False, dan kita 
tambah mistakes += 1.

Terus char_index ditambah 1. Jadi kita pindah ke karakter berikutnya.

Cek apakah sudah mencapai akhir teks. game_over = char_index >= len(current_text).

Kalau sudah akhir dan bukan mode time (bukan countdown), set game_over_flag = True 
dan timer_running = False.

Terus kita return dictionary dengan informasi penting:
- action: 'key_press' (bukan backspace atau ignored)
- index: lokasi karakter yang baru saja diketik
- correct: apakah benar atau salah
- game_over: apakah permainan selesai

Frontend akan terima informasi ini dan update UI sesuai.

CONTOH FLOW:
User ketik 'k' tapi huruf yang harus diketik adalah 'a'.
- is_correct = False
- mistakes = mistakes + 1 (kesalahan bertambah 1)
- char_index = char_index + 1 (pindah ke karakter berikutnya)
- Return: {'action': 'key_press', 'correct': False, 'index': 25, ...}
- Frontend: Tag karakter ke-25 dengan warna MERAH, pindah highlight ke karakter ke-26

Kalau user ketik 'a' dan memang seharusnya 'a':
- is_correct = True
- mistakes tetap
- char_index = char_index + 1
- Return: {'action': 'key_press', 'correct': True, 'index': 25, ...}
- Frontend: Tag karakter ke-25 dengan warna HIJAU, pindah highlight ke karakter ke-26"

═══════════════════════════════════════════════════════════════════════════════
METHOD 5: UPDATE_TIMER
═══════════════════════════════════════════════════════════════════════════════

"Method update_timer dijalankan setiap detik oleh frontend.

Fungsinya untuk update waktu. Jadi kalau user lagi ketik, waktu terus berjalan.

Pertama, cek apakah timer_running = True. Kalau False, abaikan aja.

Terus hitung berapa lama sudah berlalu: time_elapsed = sekarang - start_time.

Sekarang, ada dua case:

CASE 1: Mode TIME (Tes Kecepatan dengan countdown)
Time_left = max_time - time_elapsed.
Jadi kalau max_time = 60, dan time_elapsed = 35, maka time_left = 25.
Tiap detik, time_left berkurang 1.

Kalau time_left <= 0, berarti waktu habis. Set timer_running = False dan 
game_over_flag = True.

CASE 2: Mode DRILL (Latihan dengan elapsed time)
Time_left = time_elapsed.
Jadi time_left adalah waktu yang sudah berlalu, bukan sisa waktu.
Kalau user sudah ketik 1 menit, time_left = 60.

Frontend akan terima informasi ini dan tampilkan countdown atau elapsed time 
ke user di UI.

Jadi method ini adalah yang membuat game 'live'. Tanpa method ini, timer 
tidak akan jalan."

═══════════════════════════════════════════════════════════════════════════════
METHOD 6: GET_STATS [PERHITUNGAN WPM/CPM]
═══════════════════════════════════════════════════════════════════════════════

"Method get_stats adalah method yang paling sering ditanya. Karena di sini 
ada perhitungan WPM dan CPM.

Pertama, kita hitung time_elapsed. Kalau mode time, time_elapsed = max_time 
(60 detik). Kalau mode drill, time_elapsed = time_left (berapa lama ketika 
tadi).

Terus kita hitung net_chars. Ini adalah karakter yang diketik dengan benar.
net_chars = char_index - mistakes.

Contoh: User ketik 100 karakter, tapi 10 salah.
net_chars = 100 - 10 = 90.
Artinya user berhasil ketik 90 karakter yang benar.

Sekarang perhitungan CPM (Karakter Per Menit):
CPM = (net_chars / time_elapsed) * 60.

Contoh: net_chars = 90, time_elapsed = 60 detik.
CPM = (90 / 60) * 60 = 90.
Artinya user bisa ketik 90 karakter benar per menit.

Terus perhitungan WPM (Kata Per Menit):
WPM = CPM / 5.

Kenapa / 5? Karena standar industri menganggap 1 kata = 5 karakter.

Contoh: CPM = 90.
WPM = 90 / 5 = 18.
Artinya user bisa ketik 18 kata per menit.

Kalau net_chars negative (kesalahan lebih banyak dari ketikan), WPM dan CPM 
akan negative. Untuk mencegah ini, kita pakai max(0, wpm), jadi hasil minimum 
adalah 0.

Method ini return dictionary berisi:
- WPM: Kata per menit
- CPM: Karakter per menit
- Mistakes: Jumlah kesalahan
- TimeLeft: Sisa waktu atau waktu yang berlalu
- TimeElapsed: Waktu yang sudah berlalu

CONTOH PERHITUNGAN LENGKAP:

User tes kecepatan 60 detik. Dia ketik 300 karakter, 30 salah.

Perhitungan:
- time_elapsed = 60
- net_chars = 300 - 30 = 270
- CPM = (270 / 60) * 60 = 270
- WPM = 270 / 5 = 54
- mistakes = 30

Jadi hasil akhirnya:
{
  'WPM': 54,
  'CPM': 270,
  'Mistakes': 30,
  'TimeLeft': 0,
  'TimeElapsed': 60
}

Frontend akan tampilkan: '54 WPM, 270 CPM, 30 Kesalahan, 60 detik'.

Ini adalah hasil akhir yang akan user lihat."

═══════════════════════════════════════════════════════════════════════════════
METHOD 7: IS_GAME_OVER
═══════════════════════════════════════════════════════════════════════════════

"Method terakhir adalah is_game_over. Ini method pendek, tapi penting.

Method ini check apakah permainan sudah selesai atau belum.

Logic-nya:
- Kalau game_over_flag = True, return True (game selesai)
- ATAU kalau (bukan time mode) AND (sudah ketik semua teks) AND (timer tidak jalan), 
  return True

Jadi ada dua cara game bisa selesai:

CARA 1: Waktu habis
Jika mode time (tes kecepatan), user ketik sambil timer countdown 60, 30, 10, 0.
Pas habis, update_timer() set game_over_flag = True.

CARA 2: Teks habis
Jika mode drill (latihan), user ketik hingga akhir teks.
process_key() akan set game_over_flag = True.

Frontend akan polling method ini terus. Kalau return True, frontend tahu 
bahwa game sudah selesai, dan harus tampilkan hasil."

═══════════════════════════════════════════════════════════════════════════════
ALUR GAME LENGKAP
═══════════════════════════════════════════════════════════════════════════════

"Baik, mari kita lihat alur permainan dari awal sampai akhir.

STEP 1: USER MEMILIH MODE
User klik 'Tes Kecepatan' atau pilih 'Latihan Baris Tengah' dari dropdown.
Frontend panggil: backend.set_mode('time', 60)
Backend:
- Set game_mode = 'time'
- Set max_time = 60
- Panggil reset_game()
- reset_game() panggil load_paragraph()
- load_paragraph() generate 300 kata random
- current_text sekarang berisi teks tes kecepatan

Frontend tampilkan teks di layar.

STEP 2: USER MULAI KETIK KARAKTER PERTAMA
User tekan tombol 'a'. Frontend panggil: backend.process_key('a', 'a').

Backend:
- Cek: teks[0] = apa? Misalnya teks[0] = 'P' (huruf P besar).
- Bandingkan: char ('a') == teks[0] ('P')? Tidak.
- is_correct = False.
- mistakes = 1.
- char_index = 1 (pindah ke karakter kedua).
- start_time = time.time() (mulai timer).
- timer_running = True.
- Return: {'action': 'key_press', 'correct': False, 'index': 0, ...}

Frontend:
- Tag teks[0] dengan warna MERAH (incorrect).
- Pindah highlight ke teks[1].
- Update UI stats: mistakes = 1.

STEP 3: SETIAP DETIK, TIMER UPDATE
Frontend panggil: backend.update_timer() setiap 1 detik.

Backend:
- time_elapsed = waktu sekarang - start_time.
- time_left = 60 - time_elapsed.
- Return time_left.

Frontend:
- Tampilkan time_left di UI: '59s', '58s', '57s', ..., '0s'.

STEP 4: USER TERUS KETIK
User ketik karakter lagi. Jika benar, tag akan warna HIJAU. Jika salah, warna MERAH.
Setiap ketikan, mistakes bertambah atau tetap, char_index selalu bertambah 1.

STEP 5: USER TEKAN BACKSPACE
User tekan Backspace. Backend panggil: backend.process_key('', 'BackSpace').

Backend:
- Cek: apakah BackSpace?
- char_index = char_index - 1 (mundur 1 karakter).
- Return: {'action': 'backspace', 'index': ...}

Frontend:
- Hapus warna dari karakter sebelumnya.

STEP 6: PERMAINAN BERAKHIR - WAKTU HABIS
Timer terus countdown. Setiap detik, time_left berkurang 1.
Pas time_left = 0, update_timer() set game_over_flag = True dan timer_running = False.

Frontend:
- Cek: is_game_over() return True? Ya.
- Panggil end_game().

STEP 7: TAMPILKAN HASIL AKHIR
Frontend panggil: backend.get_stats().

Backend:
- Hitung WPM, CPM, mistakes, dst.
- Return dictionary dengan hasil.

Frontend:
- Tampilkan hasil di UI: 'WPM: 54, CPM: 270, Mistakes: 30, Time: 60s'.

STEP 8: USER TEKAN TAB + ENTER UNTUK RESET
User tekan Tab, terus tekan Enter. Frontend detect kombinasi ini.
Frontend panggil: backend.reset_game().
Ulangi dari STEP 1.

---

Jadi alurnya adalah:
User input → process_key() → update state → return info → 
frontend display → update_timer() → check game_over() → 
kalau selesai, get_stats() → display result.

Simple, kan?"



═══════════════════════════════════════════════════════════════════════════════
CLOSING
═══════════════════════════════════════════════════════════════════════════════

"Jadi kesimpulannya, backend ini adalah sistem yang:

- Sederhana tapi powerful
- Support multiple modes
- Perhitungan akurat

Setiap method punya job yang jelas. process_key handle input, update_timer handle 
waktu, get_stats handle perhitungan, dll.


